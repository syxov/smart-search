{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import Fuse from \"fuse.js\";\nimport { MinHeap } from \"@datastructures-js/heap\";\n\nexport interface Parameter<T> {\n  values: T[];\n  getSearchString?(value: T): string;\n}\n\nexport interface NavOption<T> {\n  keywords: string[];\n  parameters: Parameter<T>[];\n}\n\nexport interface SearchResult<T> {\n  option: NavOption<T>;\n  parameters: T[];\n  score: number;\n}\n\nexport class SmartSearch<T> {\n  readonly #options: readonly NavOption<T>[];\n\n  constructor(options: readonly NavOption<T>[]) {\n    this.#options = options;\n  }\n\n  search(query: string, n = 5) {\n    return this.#findTopNavOptions(query.trim(), this.#options, n);\n  }\n\n  *#combinationGenerator(\n    parameters: Parameter<T>[],\n    prefix: T[] = [],\n  ): Generator<T[]> {\n    if (parameters.length === 0) {\n      yield prefix;\n    } else {\n      const [firstParamSignal, ...restParams] = parameters;\n      for (const value of firstParamSignal.values) {\n        yield* this.#combinationGenerator(restParams, [...prefix, value]);\n      }\n    }\n  }\n\n  #findTopNavOptions(\n    userInput: string,\n    navOptions: readonly NavOption<T>[],\n    topN: number,\n  ): SearchResult<T>[] {\n    const heap = new MinHeap<SearchResult<T>>((val) => val.score);\n\n    for (const navOption of navOptions) {\n      const generator = this.#combinationGenerator(navOption.parameters);\n      for (const keyword of navOption.keywords) {\n        for (const combination of generator) {\n          const combinationString = [\n            keyword,\n            ...combination.map((value, index) => {\n              const param = navOption.parameters[index];\n              return param.getSearchString?.(value) ?? value;\n            }),\n          ].join(\"\");\n\n          const options = {\n            includeScore: true,\n            threshold: 0.7,\n          };\n\n          const fuse = new Fuse([combinationString], options);\n          const result = fuse.search(userInput);\n\n          if (result.length > 0) {\n            const searchResult = {\n              option: navOption,\n              parameters: combination,\n              score: result[0].score!,\n            };\n\n            if (heap.size() < topN) {\n              heap.push(searchResult);\n            } else if (heap.root()!.score < searchResult.score!) {\n              heap.extractRoot();\n              heap.push(searchResult);\n            }\n          }\n        }\n      }\n    }\n\n    return heap.sort();\n  }\n}\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,kBAAiB;AACjB,kBAAwB;AAkBjB,IAAM,cAAN,MAAqB;AAAA,EACjB;AAAA,EAET,YAAY,SAAkC;AAC5C,SAAK,WAAW;AAAA,EAClB;AAAA,EAEA,OAAO,OAAe,IAAI,GAAG;AAC3B,WAAO,KAAK,mBAAmB,MAAM,KAAK,GAAG,KAAK,UAAU,CAAC;AAAA,EAC/D;AAAA,EAEA,CAAC,sBACC,YACA,SAAc,CAAC,GACC;AAChB,QAAI,WAAW,WAAW,GAAG;AAC3B,YAAM;AAAA,IACR,OAAO;AACL,YAAM,CAAC,kBAAkB,GAAG,UAAU,IAAI;AAC1C,iBAAW,SAAS,iBAAiB,QAAQ;AAC3C,eAAO,KAAK,sBAAsB,YAAY,CAAC,GAAG,QAAQ,KAAK,CAAC;AAAA,MAClE;AAAA,IACF;AAAA,EACF;AAAA,EAEA,mBACE,WACA,YACA,MACmB;AACnB,UAAM,OAAO,IAAI,oBAAyB,CAAC,QAAQ,IAAI,KAAK;AAE5D,eAAW,aAAa,YAAY;AAClC,YAAM,YAAY,KAAK,sBAAsB,UAAU,UAAU;AACjE,iBAAW,WAAW,UAAU,UAAU;AACxC,mBAAW,eAAe,WAAW;AACnC,gBAAM,oBAAoB;AAAA,YACxB;AAAA,YACA,GAAG,YAAY,IAAI,CAAC,OAAO,UAAU;AACnC,oBAAM,QAAQ,UAAU,WAAW,KAAK;AACxC,qBAAO,MAAM,kBAAkB,KAAK,KAAK;AAAA,YAC3C,CAAC;AAAA,UACH,EAAE,KAAK,EAAE;AAET,gBAAM,UAAU;AAAA,YACd,cAAc;AAAA,YACd,WAAW;AAAA,UACb;AAEA,gBAAM,OAAO,IAAI,YAAAA,QAAK,CAAC,iBAAiB,GAAG,OAAO;AAClD,gBAAM,SAAS,KAAK,OAAO,SAAS;AAEpC,cAAI,OAAO,SAAS,GAAG;AACrB,kBAAM,eAAe;AAAA,cACnB,QAAQ;AAAA,cACR,YAAY;AAAA,cACZ,OAAO,OAAO,CAAC,EAAE;AAAA,YACnB;AAEA,gBAAI,KAAK,KAAK,IAAI,MAAM;AACtB,mBAAK,KAAK,YAAY;AAAA,YACxB,WAAW,KAAK,KAAK,EAAG,QAAQ,aAAa,OAAQ;AACnD,mBAAK,YAAY;AACjB,mBAAK,KAAK,YAAY;AAAA,YACxB;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAEA,WAAO,KAAK,KAAK;AAAA,EACnB;AACF;","names":["Fuse"]}